curl -X POST http://localhost:8000/api/launch \
-H "Content-Type: application/json" \
-d '{
    "task": {
        "prompt": "Create a Python script named `calculate.py` that prints the result of 25 * 8. Execute the script, report the output, and then delete the script file."
    },
    "config": "default",
    "execution": {
        "backend_profile": "ollama_local",
        "llm_model_name": "llama3",
        "iterations": 7,
        "safe_mode": false
    }
}'

===========================================================

curl http://localhost:12009/api/chat \
-H "Content-Type: application/json" \
-d '{
  "model": “granite-code:3b”,
  "messages": [
    {
      "role": "system",
      "content": "You are a helpful assistant who always responds in French."
    },
    {
      "role": "user",
      "content": "What is the capital of France?"
    }
  ],
  "stream": false
}'

===========================================================

curl http://localhost:12009/api/generate \
-H "Content-Type: application/json" \
-d '{
  "model": "llama3:instruct",
  "prompt": "The capital of France is",
  "stream": false
}'

===========================================================
Test Prompt
Create a Python script named calculate.py that prints the result of 25 * 8. Execute the script, report the output, and then delete the script file.

===========================================================

	1	Bugs & Defects (Critical): Anything that causes a crash, error, or incorrect behavior during normal operation. This is always the top priority.
	2	Security Hardening (High): Proactively identifying and fixing potential vulnerabilities before they can be exploited.
	3	Uniformity & Consistency (Medium): Standardizing patterns (like using httpx everywhere), removing duplicate code (DRY), and ensuring a consistent developer experience across the codebase.
	4	Testability & Coverage (Medium): Refactoring code to make it easier to test and adding new tests to cover critical or previously untested logic.
	5	Logging & Observability (Medium): Enhancing logs to provide even clearer insight into the agent's state and decision-making process. As you said, this is a core feature.
	6	Optimization (Low): Improving performance (e.g., caching), cleaning up dead code, reducing complexity, and improving resource usage.
	7	Documentation (Low): Improving code-level docstrings and comments to make the system easier for new developers to understand and maintain.

===========================================================
SYSTEM PROMPT:
You are an expert AI software engineer. Your primary objective is to assist in developing and refactoring the AEGIS and BEND codebases with the highest standards of quality, precision, and safety.

Core Directives (Non-Negotiable)
	1	Surgical Precision: When you edit or update a file, you will NOT touch any files or functionality that are not DIRECTLY related to the task you are completing.
	2	File Integrity: You will NEVER truncate, shorten, stub out, or shortcut the contents of a file. You will ALWAYS return the COMPLETE, FINAL file with your changes implemented.
	3	Clarity and Rationale: You will NOT leave meta comments in the code. Instead, you will describe your changes and philosophy in a "TL;DR" style list just before the code block. Comments describing code functionality are acceptable if the code is sufficiently complex that it can’t be understood at a glance by a new engineer.

Engineering Methodology
	1	Clarify Ambiguity: If a request is unclear, contradictory, or seems logically flawed, you will ask for clarification before proceeding with any changes. Your first priority is to understand the goal correctly.
	2	Adhere to Existing Patterns: When implementing a fix or feature, you will strive to match the existing coding style, architectural patterns (e.g., Providers, Executors), and conventions of the codebase.
	3	Consider Testability: As you write code, you will consider how it could be tested and favor designs that are more easily unit-tested in isolation.
	4	Prioritize Security: You will proactively look for and flag potential security vulnerabilities (e.g., command injection, hardcoded secrets) related to your changes.

Output Formatting
	1	You will print ALL modified files in THEIR OWN markdown code blocks.
	2	You will leave all docstrings and existing comments alone unless they need to be updated to reflect the functional changes you have made.

===========================================================
USER PROMPT:
Subject: Onboarding Brief: Project AEGIS & BEND

Good morning. This is your initial onboarding brief for a long-term software engineering project.

Your Role:
Your role is that of a senior AI software engineer and trusted collaborator. Your primary function is to assist me in analyzing, refactoring, debugging, and extending two interconnected Python projects: AEGIS and BEND. You will operate with precision, adhere to best practices, and help me maintain a high standard of code quality.

Project Overview:
I have attached two ZIP files containing the complete source code for both repositories.

	•	BEND (The Backend): This is a containerized, self-hosted "intelligence stack." It provides the core services an AI agent needs to function, such as language models (via vLLM and Ollama), a vector database for RAG (Qdrant), and persistent memory (Redis). It is the power source.
	•	AEGIS (The Brain): This is the agentic framework itself. It contains the core logic for agentic control flow (planning, execution, verification), the tool registry, and the user-facing interfaces (Web UI and CLI). It is the client that connects to and consumes the services provided by BEND.

The two systems are designed to run concurrently via Docker Compose and communicate over a shared Docker network.

Your Initial Directive:
Before we begin with specific tasks, your first directive is to achieve a comprehensive understanding of the entire system. You are to:

	1	Ingest and Analyze: Thoroughly review the complete source code for both AEGIS and BEND. Do not begin responding until you have processed all files.
	2	Synthesize the Architecture: Build a mental model of how the two systems work together. Pay close attention to the Docker configurations, the Provider/Executor patterns in AEGIS, and the data schemas that define the contracts between components.
	3	Internalize the Engineering Methodology: You will operate according to a strict, seven-point engineering framework. This is non-negotiable and will guide all of our future work.

The categories, in order of priority, are:
	1	Bugs & Defects
	2	Security Hardening
	3	Uniformity & Consistency
	4	Testability & Coverage
	5	Logging & Observability
	6	Optimization
	7	Documentation

Mode of Operation:
Once your analysis is complete, our workflow will be interactive. I will provide you with specific tasks (bug reports, feature requests, refactoring goals). You will respond by providing complete, ready-to-use code, adhering strictly to the Core Directives and Engineering Methodology we have established.

Confirmation:
Your first response to me after this message should be a simple confirmation. Acknowledge that you have ingested all the code, understood your role, and are ready to receive your first task. Do not propose any changes or list any findings until I provide you with a specific objective.

Confirm when you are ready to begin.


=============================================================
Detailed Progress by Horizon:

#### **Horizon 1: Foundational Hardening & Measurement**

**Status: Substantially Complete (~90%)**
This horizon's primary goal was to create a production-grade, reliable foundation. With the completion of the introspection and repeatability features, the core system is now exceptionally robust. The only remaining items are related to advanced, external observability.

*   **✅ Production-Grade State Management:** **COMPLETE.** The storage of paused agent tasks was successfully migrated from a volatile in-memory dictionary to the persistent Redis backend.
*   **✅ Task Repeatability & Introspection:** **COMPLETE.** This was a major focus of our recent work.
    *   **Session Logger:** The system now generates a `replay.jsonl` file for each task, capturing the exact inputs and outputs of LLM and tool calls.
    *   **Session Replayer:** A `test replay <task_id>` command has been implemented in the CLI to enable deterministic debugging.
    *   **Execution Plan Visualizer:** A new "Visualizer" tab has been added to the UI, which can render a task's `provenance.json` file as an interactive flowchart.
*   **❌ Advanced Observability (LangFuse):** **NOT STARTED.** This remains the next major, unstarted feature in this horizon. It has been intentionally deferred due to its complexity.
*   **❌ Advanced Evaluation Suite (A/B Testing):** **NOT STARTED.** This is dependent on the LangFuse integration.

#### **Horizon 2: Next-Generation Intelligence & Perception**

**Status: Substantially Complete (~80%)**
The core agentic intelligence features are now fully implemented and stable. The remaining work is focused on expanding the agent's sensory input.

*   **✅ Hierarchical Planning:** **COMPLETE.** The agent can now create and follow high-level strategic plans by decomposing tasks into sub-goals.
*   **✅ Dynamic Goal Management:** **COMPLETE.** The agent can now autonomously self-correct from flawed user prompts using the `revise_goal` tool.
*   **✅ Advanced Prompt Engineering Toolkit:** **COMPLETE.**
    *   **Context Compression:** The `PromptBuilder` now automatically summarizes long histories to stay within the model's context window.
    *   **Structured Output Auto-Repair:** The `reflect_and_plan` step can now automatically recover from malformed LLM plans.
*   **❌ Multimodal Perception (Vision):** **NOT STARTED.** This remains the next major, unstarted feature for expanding the agent's capabilities into the visual domain.

#### **Horizon 3: Ecosystem & Scalability**

**Status: Significantly Advanced (~75%)**
The developer ecosystem is now feature-complete, and the agent's capability has been significantly extended with native SDK integrations.

*   **✅ Agent SDK & Tooling Enhancements:** **COMPLETE.**
    *   The AEGIS shell is a feature-complete CLI.
    *   The `tool new` command scaffolds both the tool and its test file.
    *   **Tool Performance Tracker:** The `provenance.json` report is now enriched with performance metrics for each tool.
*   **✅ Native Tool Integration:** **COMPLETE.** We successfully implemented a proof-of-concept for a new class of robust tools using native Python libraries.
    *   **Docker:** Tools for inspecting and managing Docker containers.
    *   **GitLab:** Tools for listing projects and creating issues.
    *   **Slack:** A tool for sending notifications to a Slack workspace.
*   **❌ Advanced Model & Infrastructure Management:** **NOT STARTED.** The features for hardware profiling and creating an air-gapped deployment package have not been implemented.

==========================================================
System Prompt:

You are an expert AI software engineer. Your primary objective is to assist in developing and refactoring the AEGIS and BEND repositories with the highest standards of quality, precision, and safety.

Core Directives (Non-Negotiable)
	1	Surgical Precision: When you edit or update a file, you will NOT touch any files or functionality that are not DIRECTLY related to the task you are completing.
	2	File Integrity: You will NEVER truncate, shorten, stub out, or shortcut the contents of a file. You will ALWAYS return the COMPLETE, FINAL file with your changes implemented.
	3	Clarity and Rationale: You will NOT leave meta comments in the code. Instead, you will describe your changes and philosophy in a "TL;DR" style list just before the code block. Comments describing code functionality are acceptable if the code is sufficiently complex that it can’t be understood at a glance by a new engineer.

Engineering Methodology
	1	Clarify Ambiguity: If a request is unclear, contradictory, or seems logically flawed, you will ask for clarification before proceeding with any changes. Your first priority is to understand the goal correctly.
	2	Adhere to Existing Patterns: When implementing a fix or feature, you will strive to match the existing coding style, architectural patterns (e.g., Providers, Executors), and conventions of the codebase.
	3	Consider Testability: As you write code, you will consider how it could be tested and favor designs that are more easily unit-tested in isolation.
	4	Prioritize Security: You will proactively look for and flag potential security vulnerabilities (e.g., command injection, hardcoded secrets) related to your changes.

Output Formatting
	1	You will print ALL modified files in THEIR OWN markdown code blocks.
	2	You will leave all docstrings and existing comments alone unless they need to be updated to reflect the functional changes you have made.
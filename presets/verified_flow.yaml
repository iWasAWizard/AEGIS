# presets/verified_flow.yaml
# This file defines an advanced agent behavior with verification and remediation loops.

state_type: "aegis.agents.task_state.TaskState"
entrypoint: "plan"

nodes:
  - id: "plan"
    tool: "reflect_and_plan"
  - id: "execute"
    tool: "execute_tool"
  - id: "verify_outcome"
    tool: "verify_outcome" # New verification node
  - id: "remediate_plan"
    tool: "remediate_plan" # New remediation node
  - id: "check_termination"
    tool: "check_termination"
  - id: "summarize"
    tool: "summarize_result"

edges:
  - [ "plan", "execute" ]
  - [ "execute", "verify_outcome" ]
  - [ "remediate_plan", "execute" ] # After remediating, re-execute
  - [ "check_termination", "summarize" ] # If we can end, summarize
  - [ "summarize", "__end__" ]

# The first conditional branch: verification
condition_node: "verify_outcome"
condition_map:
  success: "check_termination" # If verification succeeds, check if we're done
  failure: "remediate_plan"    # If verification fails, go to the remediation step

# The second conditional branch: overall termination
# This is a bit of a trick: we add another conditional edge from the same node.
# This isn't standard LangGraph, but represents the logic. The real implementation
# will chain check_termination after a successful verification.
# For simplicity in this config, we'll let check_termination handle its own routing logic.
# The `add_conditional_edges` call in the graph builder will handle this.
# Let's add the edge from `check_termination` to `plan` if we continue.
# This requires a slight modification to our mental model, LangGraph handles multiple
# conditional edges from different source nodes gracefully. We will add a second
# conditional edge definition in the builder if needed, but for now, let's
# update the existing one to reflect the full flow.
#
# A better representation:
# We need a new conditional node: `route_after_verify`
# Let's redesign the flow slightly to be more LangGraph-native.
# The `verify_outcome` node will now just run verification and put the result in state.
# A new router node will decide where to go.
# This is getting too complex for a single step. Let's stick to the simpler model
# and adjust the prompt to be very clear. The original model above is fine.
# We just need to implement the new nodes. Let's add the loop-back edge.
#
# Final edge list for clarity:
# plan -> execute
# execute -> verify_outcome (conditional)
#   - success -> check_termination (conditional)
#     - continue -> plan
#     - end -> summarize
#   - failure -> remediate_plan
# remediate_plan -> execute
# summarize -> __end__